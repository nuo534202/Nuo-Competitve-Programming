# Codeforces Round 1076 Solution

比赛链接: [Codeforces Round 1076 (Div.3)](https://codeforces.com/contest/2193)

## A. DBMB and the Array

对 $a$ 数组求和，当 $s$ 大于等于 $a$ 数组的和 $sum$ 且 $(s - sum) \% x = 0$ 时，输出 `YES`，否则输出 `NO`。

时间复杂度： $O(\sum n)$。

## B. Reverse a Permutation

一个字典序最大的长度为 $n$ 的排列满足 $p_i = n - i + 1$ 对于所有 $1 \leq i \leq n$。要输出的最大字典序的排列一定要尽量满足这个条件。

我们只需要从 $i = 1$ 到 $n$ 遍历每一个位置 $i$，如果 $p$ 数组当前位置的值 $p_i$ 满足 $p_i = n - i + 1$ 则直接输出；否则，找到 $p_j = n - i + 1$ ($i < j$)，并将 $[i, j]$ 范围内的序列反转输出。接着按照顺序输出 $[j + 1, n]$ 范围内的 $p$ 数组值即可。

利用 $vis$ 数组记录 $p_i$ 排列每一个值的位置下标就可以 $O(1)$ 的找出 $p_j = n - i + 1$ 的位置。

时间复杂度： $O(\sum n)$。

## C. Replace and Sum

- 要求 $[l, r]$ 范围内 $a$ 数组和的最大值，我们首先要做的就是求出 $a$ 数组每一个位置的最大值，因为只有当每个位置都取到最大值的时候，区间和才会最大。
- 对于每一个 $a_i$，其最大值来源为 $b_i$ 和 $a_{i + 1}$。由于每一个 $b_i$ 固定不变，因此我们只需要找出 $a_{i + 1}$ 的最大值即可。
- 因此求每一个 $a_i$ 的最大值可以从后往前遍历 $a$ 数组，利用 $a_i = \max(a_i, b_i, a_{i + 1})$ 求出最大值。这个过程也等价于先对每一个位置进行操作 $a_i = \max(a_i, b_i)$，再进行 $a_i = \max(a_i, a_{i + 1})$，这样子还能把 $b$ 数组的空间给节省掉。
- 求出每一个位置的最大值后，我们对 $a$ 数组求前缀和，这样子就能在 $O(1)$ 时间内求出任意区间和 $[l, r]$。

时间复杂度： $O(\sum n + \sum q)$。

## D. Monster Game

- $x$ 的取值一定是 $a$ 数组中的值。如果 $x$ 的取值不是 $a$ 数组中的值：
  - 假设 $a$ 数组中存在大于 $x$ 的值，那么将 $x$ 的取值替换为 $a$ 数组中大于 $x$ 的最小值，剑的数量不变，能通过的关卡数量不变，但是由于 $x$ 变大了，得分就变大了。
  - 假如 $a$ 数组中不存在大于 $x$ 的值，那么就没有可用的剑，得分为 $0$，一定不是最优答案。
  - 因此，将 $x$ 取为 $a$ 数组中大于 $x$ 的最小值，一定不会比原来更差。
- 根据以上结论，我们可以对 $a$ 数组进行排序，然后枚举每一个 $a_i$ 作为 $x$ 的取值，这样就能 $O(1)$ 得出可以使用的剑的数量 $n - i + 1$。
  - 可以通过的关卡数量为 $b$ 数组前缀和小于等于 $n - i + 1$ 的最大前缀和长度。
  - 对 $b$ 数组维护前缀和，再二分找出最大前缀和长度即可。

时间复杂度： $O(\sum n\log n)$。

## E. Product Queries

- 考虑 $dp$，设 $dp_i$ 为 乘积为 $i$ 的答案。
- 对于满足 $i < j$ 和 $j\ \% \ i = 0$ 条件的 $i$ 和 $j$，转移方程为 $dp_j = \min(dp_j, dp_{\frac{j}{i}})$。
- 只需要先枚举 $i$，再枚举 $i$ 的倍数 $j$ 即可完成转移。

时间复杂度： $O(\sum n\log n)$。